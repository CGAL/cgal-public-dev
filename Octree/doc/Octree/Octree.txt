namespace CGAL {

/*!
\mainpage User Manual
\anchor Chapter_Octree

\cgalAutoToc
\author Jackson Campolattaro

\section Section_Octree_Introduction Introduction

An octree is a commonly used data structure that subdivides 3d space.
The Octree package provides the Octree and Node classes.

\todo I need to discuss use-cases

Note that the octree will often be outperformed by Spacial_searching's kD-tree.
Octrees are most useful when implementing algorithms that require nodes without high aspect-ratios.

\section Section_Usage Usage

\subsection Section_Octree_Building Building an Octree

\subsubsection Section_Octree_Example_Point_Vector Building an Octree from a Vector of Points

This example illustrates how to create an octree from a `std::vector`.

An `std::vector<Point_3>` is manually filled with points.
The vector is used as the point set,
a `CGAL::Identity_property_map` it automatically set as the octree's map type, so a map doesn't need to be provided.

\cgalExample{Octree/Octree_build_from_Point_vector.cpp}

\subsubsection Section_Octree_Example_Point_Set Building an Octree from a Point_set_3

This example illustrates how to create an octree from a `Point_set_3` loaded from a file.
It also shows a more explicit way of setting the split criteria when refining the tree.

An octree is constructed from the point set and its map.
The tree is refined with a max-depth (deepest node allowed) of 10,
and a bucket size (maximum number of points contained by a single node) of 20.
The tree is then printed to the standard output.

The split criterion is manually constructed and passed to the refine method.

\cgalExample{Octree/Octree_build_from_Point_set.cpp}

\subsubsection Section_Octree_Example_Custom_Split_Criterion Building an Octree with a Custom Split Criterion

This example illustrates how to refine an octree using a split criterion that isn't provided by default.

The criterion is a functor created by the user to determine whether a node needs to be split.
This particular criterion sets a node's bucket size as a ratio of its depth.
For example, for a ratio of 2, a node at depth 2 can hold 4 points, a node at depth 7 can hold 14.

\cgalExample{Octree/Octree_build_with_custom_split.cpp}

\subsection Section_Octree_Nearest_Neighbor Nearest Neighbor

\subsubsection Section_Octree_Example_Nearest_Neighbor Finding the Nearest Neighbor of a Point

This example illustrates how to use an octree to accelerate the search for points close to a location.

Points are loaded from a file and an octree is built.
The nearest neighbor method is invoked for several input points.
A k value of 1 is used to find the single closest point.
Results are put in a vector, and then printed.

\cgalExample{Octree/Octree_find_nearest_neighbor.cpp}

\subsection Section_Octree_Traversal Traversal

\subsubsection Section_Octree_Example_Manual_Traveral Manual Traversal

This example demonstrates ways of accessing different nodes of a tree, given a reference to one.

If you have the root node, it's possible to get to its children using the subscript operator (`[]`).
Values from 0-7 provide access to the different children.
Using the operator on a leaf node is considered undefined behavior.

For non-root nodes, it's possible to access parent nodes using the `parent` accessor.
Note that the accessor returns a pointer and not a reference,
calling the root node's parent accessor will return null.

These accessors and operators can be chained to access any node in the tree in a single line of code.

\todo I plan to add an enum for node indices, so I can refer to them by name (e.g. LEFT_TOP_FRONT)

\cgalExample{Octree/Octree_traversal_manual.cpp}

\subsubsection Section_Octree_Example_Preorder_Traversal Preorder Traversal

This example illustrates how to use the provided traversals.

A tree is constructed, and a traversal is used to create a range that can be iterated over using a for-each loop.
The default output operator for the octree uses the preorder traversal to do a pretty-print of the tree structure.
In this case, we print out the nodes of the tree without indentation instead.

\cgalExample{Octree/Octree_traversal_preorder.cpp}

<!--
\subsubsection Section_Octree_Example_Custom_Traversal Using a Custom Traversal Method

e.g. I've build a tree and I want to print it out, but layer by layer

\cgalExample{Octree/Octree_traversal_custom.cpp}

!-->
\subsubsection Section_Octree_Grade Grading an octree

This example demonstrates how to use the grade method to eliminate large jumps in depth within the octree.

A tree is created such that one node is split many more times than those it borders.
`grade()` splits the octree's nodes so that adjacent nodes never have a difference in depth greater than one.
The tree is printed before and after grading, so that the differences are visible.

\cgalExample{Octree/Octree_grade.cpp}

\section Section_Octree_Performance Performance

\subsection Section_Octree_Performance_Comparison Comparison with kD Tree

e.g. When is an octree the right choice?

\section Section_Octree_Software_Design Software Design

\subsection Subsection_Octree_Splitting_Rules Splitting Rules
\subsection Subsection_Octree_Walker_Rules Walker Rules
*/

}

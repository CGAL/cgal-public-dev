namespace CGAL {
/*!

\mainpage User Manual
\anchor Chapter_Implicit_Surface_Reconstruction
\cgalAutoToc

\authors Pierre Alliez, Laurent Saboret, Ga&euml;l Guennebaud, Tong Zhao, Hongyi Liu

\section Implicit_surface_reconstruction_3Introduction Introduction

This \cgal component implements three surface reconstruction methods, which
take as input point sets with oriented normals / unoriented normals and computes an
implicit function. (We assume that the input points contain no outliers
and little noise.) The output surface mesh is generated by extracting
an isosurface of this function with the \cgal Surface Mesh Generator
\cgalCite{cgal:ry-gsddrm-06} or potentially with any other surface
contouring algorithm.

\cgalFigureBegin{Implicit_surface_reconstruction_3figintroduction,introduction.jpg}
Poisson surface reconstruction.\n
Left: 17K points sampled on the statue of an elephant with a Minolta laser scanner. Right: reconstructed surface mesh.
\cgalFigureEnd

More specifically, the core surface reconstruction algorithm consists
of computing an implicit function which is an approximate indicator
function of the inferred solid (Poisson Surface Reconstruction -
referred to as Poisson, Spectral Surface Reconstruction - referred
to as Spectral, Smooth Signed Distance - referred to as SSD). Poisson/Spectral/SSD is a two steps process: it requires
solving for the implicit function before function evaluation.

\note A \ref tuto_reconstruction "detailed tutorial on surface reconstruction"
is provided with a guide to choose the most appropriate method along
with pre- and post-processing.


\section Implicit_surface_reconstruction_3Common Common Reconstruction Pipeline

Surface reconstruction from point sets is often a sequential process
with the following steps: 1) Scanning and scan alignment produce a set
of points or points with normals; 2) Outlier removal; 3)
Simplification to reduce the number of input points; 4) Smoothing to
reduce noise in the input data; 5) Normal estimation and orientation
when the normals are not already provided by the acquisition device;
and 6) Surface reconstruction.

\cgal provides algorithms for all steps listed above except alignment.

Chapter \ref chappoint_set_processing_3 "Point Set Processing"
describes algorithms to pre-process the point set before
reconstruction with functions devoted to the simplification, outlier
removal, smoothing, normal estimation and normal orientation.

\cgalFigureBegin{Poisson_surface_reconstruction_3figpipeline,pipeline.jpg}
Common surface reconstruction pipeline.
\cgalFigureEnd

\section Implicit_surface_reconstruction_3Implicit Implicit Functions

CGAL currently provides two implicit functions, namely Poisson Implicit Function
and Spectral Implicit Function.

\subsection Implicit_surface_reconstruction_3Poisson Poisson

Given a set of 3D points with oriented normals (denoted oriented
points in the sequel) sampled on the boundary of a 3D solid, the
Poisson Surface Reconstruction method \cgalCite{Kazhdan06} solves for an
approximate indicator function of the inferred solid, whose gradient
best matches the input normals. The output scalar function,
represented in an adaptive octree, is then iso-contoured using an
adaptive marching cubes.

\cgal implements a variant of this algorithm which solves for a
piecewise linear function on a 3D Delaunay triangulation instead of an
adaptive octree. The algorithm takes as input a set of 3D oriented
points. It builds a 3D Delaunay triangulation from these points and
refines it by Delaunay refinement so as to remove all badly shaped
(non isotropic) tetrahedra and to tessellate a loose bounding box of
the input oriented points. The normal of each Steiner point added
during refinement is set to zero. It then solves for a scalar
indicator function \f$ f\f$ represented as a piecewise linear function
over the refined triangulation. More specifically, it solves for the
Poisson equation \f$ \Delta f = div(\mathbf{n})\f$ at each vertex of
the triangulation using a sparse linear solver. Eventually, the \cgal
surface mesh generator extracts an isosurface with function value set
by default to be the median value of \f$ f\f$ at all input points.


\subsection Implicit_surface_reconstruction_3Spectral Spectral

Given a set of 3D points with unoriented normals sampled on the boundary of a 3D
solid, the Spectral Surface Reconstruction method \cgalCite{cgal:a-vvrup-07}
computes an implicit function by solving a generalized eigenvalue problem
such that its gradient is most aligned with the principal axes of a tensor field.
The principal axes and eccentricities of the tensor field locally represent
respectively the most likely direction of the normal to the surface, and the
confidence in this direction estimation.

\subsection Implicit_surface_reconstruction_3SSD SSD

Given a set of 3D points with oriented normals (denoted oriented
points in the sequel) sampled on the boundary of a 3D solid, the
Smooth Signhed Distance Surface Reconstruction method \cgalCite{CalakliT11SSD} 
solves for a smoothed approximation of the continuous signed distance function. 
The gradient of the approximated function is encouraged to have unit length and 
align with the normal direction of input point clouds near the surface. Comparing 
to Poisson Surface Reconstruction where the indicator function is discrete, 
introducing the gradient of the signed distance function is more natural as the 
function is continuous. The energy term of SSD reconstruction also incorporates 
an additional regularization term that provies more controlness on the smoothness 
of reconstruction output.


\section Implicit_surface_reconstruction_3Function Reconstruction Function

Three global functions are provided for three reconstruction methods respectively: `poisson_surface_reconstruction_delaunay()` is provided for Poisson, 
`spectral_surface_reconstruction_delaunay()` is provided for Spectral, 
and `ssd_surface_reconstruction_delaunay()` for SSD.  They all take points with 
normals as input and handle the whole reconstruction pipeline:

- Create a spatial discretization using octree based discretization or Delaunay refinement 
- Compute the implicit function
- Reconstruct the surface with a given precision using the \cgal
surface mesh generator based on the spacial discretization
\cgalCite{cgal:ry-gsddrm-06} \cgalCite{cgal:bo-pgsms-05}
- Output the result in a polygon mesh.

The free function aims at providing a quick and user-friendly API for
Implicit reconstruction. Advanced users may be interested in using the
class (see \ref Implicit_surface_reconstruction_3Class) which allows
them, for example, to use another surface mesher or a different output
structure.

\subsection Implicit_surface_reconstruction_3Example_function Example

The following example reads a point set and reconstructs a surface using Poisson reconstruction.

\cgalExample{Implicit_surface_reconstruction_3/poisson_reconstruction_function.cpp}

The following example reads a point set and reconstructs a surface using Spectral reconstruction.

\cgalExample{Implicit_surface_reconstruction_3/spectral_reconstruction_function.cpp}

The following example reads a point set and reconstructs a surface using SSD reconstruction.

\cgalExample{Implicit_surface_reconstruction_3/ssd_reconstruction_function.cpp}

\section Implicit_surface_reconstruction_3Class Reconstruction Class

The class template declaration is `template<class Gt, class PointRange, class NormalMap> class Implicit_reconstruction_function` where
`Gt` is a geometric traits class, `PointRange` is a model of Range and `NormalMap` is a model of property_map.

For details see: `Implicit_reconstruction_function<GeomTraits, PointRange, NormalMap>`

\subsection Implicit_surface_reconstruction_3Example_class Example

The following example reads a point set, creates a Poisson implicit function and reconstructs a surface.

\cgalExample{Implicit_surface_reconstruction_3/poisson_reconstruction_example.cpp}

The following example reads a point set, creates a Spectral implicit function and reconstructs a surface.

\cgalExample{Implicit_surface_reconstruction_3/spectral_reconstruction_example.cpp}

The following example reads a point set, creates a SSD implicit function and reconstructs a surface.

\cgalExample{Implicit_surface_reconstruction_3/ssd_reconstruction_example.cpp}

\subsection Implicit_surface_reconstruction_3Discretization Discretization

Two discretization methods are provided. The Delaunay refinement takes input points and iteratively refine the spatial discretization. The octree-based method builds the discretization using an octree with predefined maximum depth, producing a triangulation of the space where the number of vertices is less sensitive to the size of the input point cloud. Options are provided in `Implicit_reconstruction_function::initialize_point_map()` and in each reconstruction individual function wrapper as a boolean parameter. 

\subsection Implicit_surface_reconstruction_3Contouring Contouring

The computed implicit functions can be iso-contoured to reconstruct a
surface by using the \cgal surface mesh generator
\cgalCite{cgal:ry-gsddrm-06} \cgalCite{cgal:bo-pgsms-05} :

`make_surface_mesh()`

The parameter `Tag` affects the behavior of `make_surface_mesh()`:
- `Manifold_tag`: the output mesh is guaranteed to be a manifold surface without boundary.
- `Manifold_with_boundary_tag`: the output mesh is guaranteed to be manifold and may have boundaries.
- `Non_manifold_tag`: the output mesh has no guarantee and hence is outputted as a polygon soup.

\subsection Implicit_surface_reconstruction_3Output Output

The surface reconstructed by `make_surface_mesh()` is required to be a
model of the concept `SurfaceMeshComplex_2InTriangulation_3`, a data
structure devised to represent a two dimensional complex embedded into
a three dimensional triangulation.

`SurfaceMeshComplex_2InTriangulation_3` defines the methods to traverse the reconstructed surface, and e.g. convert it to a triangle soup.

Other \cgal components provide functions to write the reconstructed
surface mesh to the %Object File Format (OFF) \cgalCite{cgal:p-gmgv16-96}
and to convert it to a polyhedron (when it is manifold):
- `output_surface_facets_to_off()`
- `output_surface_facets_to_polyhedron()`

See \ref Implicit_surface_reconstruction_3/poisson_reconstruction_example.cpp "poisson_reconstruction_example.cpp" example above.

\section surface_reconstruction_section_case_studies Case Studies

The surface reconstruction problem being inherently ill-posed, the
proposed algorithm does not pretend to reconstruct all kinds of
surfaces with arbitrary sampling conditions. This section provides the
user with some hints about the ideal sampling and contouring
conditions, and depicts some failure cases when these conditions are
not matched.

\subsection Implicit_surface_reconstruction_3CPoisson Poisson

\subsubsection Implicit_surface_reconstruction_3PIdealConditions Ideal Conditions

The user must keep in mind that the Poisson surface reconstruction
algorithm comprises two phases (computing the implicit function from
the input point set and contouring an iso-surface of this
function). Both require some care in terms of sampling conditions and
parameter tuning.

\subsubsection Implicit_surface_reconstruction_3PPointSet Point Set

Ideally the current implementation of the Poisson surface
reconstruction method expects a dense 3D oriented point set (typically
matching the epsilon-sampling condition \cgalCite{cgal:bo-pgsms-05}) and
sampled over a closed, smooth surface. Oriented herein means that all
3D points must come with consistently oriented normals to the inferred
surface.  \cgalFigureRef{Poisson_surface_reconstruction_3figbimba} and \cgalFigureRef{Poisson_surface_reconstruction_3figeros}
illustrate cases where these ideal conditions are met.

\cgalFigureBegin{Poisson_surface_reconstruction_3figbimba,bimba.jpg}
Poisson reconstruction. Left: 120K points sampled on a statue (Minolta laser scanner). Right: reconstructed surface mesh.
\cgalFigureEnd

\cgalFigureBegin{Poisson_surface_reconstruction_3figeros,eros.jpg}
Left: 120K points sampled on a statue (Minolta laser scanner). Right: reconstructed surface mesh.
\cgalFigureEnd

The algorithm is fairly robust to anisotropic sampling and to
noise. It is also robust to missing data through filling the
corresponding holes as the algorithm is designed to reconstruct the
indicator function of an inferred solid (see
\cgalFigureRef{Poisson_surface_reconstruction_3figholes_good}).

\cgalFigureBegin{Poisson_surface_reconstruction_3figholes_good,holes_good.jpg}
Top left: 65K points sampled on a hand (Kreon laser scanner). Bottom left: the point set is highly anisotropic due to the scanning technology. Right: reconstructed surface mesh and closeup. The holes are properly closed.
\cgalFigureEnd

The algorithm is in general not robust to outliers, although a few
outliers do not always create a failure, see
\cgalFigureRef{Poisson_surface_reconstruction_3figoutliers}.

\cgalFigureBegin{Poisson_surface_reconstruction_3figoutliers,outliers.jpg}
Left: 70K points sampled on an elephant with few outliers emphasized with disks. Right: reconstructed surface mesh.
\cgalFigureEnd

The algorithm works well even when the inferred surface is composed of
several connected components, provided that both all normals are
properly estimated and oriented (the current \cgal normal orienter
algorithm may fail in some cases, see `mst_orient_normals()`),
and that the final contouring algorithm is properly seeded for each
component. When the inferred surface is composed of several nested
connected components care should be taken to orient the normals of
each component in alternation (inward/outward) so that the final
contouring stage picks a proper contouring value.

\subsubsection Implicit_surface_reconstruction_3PSolverP Poisson Solver's Parameters

There is only one parameter that requires tuning when computing the implicit function using Poisson solver: the data fitting term as described in \cgalCite{Kazhdan13ScreenedPoisson}. This energy term penalizes the magnitude of implicit value on input data points and enforce the isosurface to go across them. While the unscreened Poisson reconstruction often gives an over-smoothed surface, increase the weight of data fitting term help recover the reconstruction result (see \cgalFigureRef{Implicit_surface_reconstruction_3figsPoissonSolverP}). Note in the figure how the surface smoothness as well as the distance to original data points changes as data fitting term increases. Due to scaling issue, the magnitude of data fitting term should change based on the input accordingly.

\cgalFigureBegin{Implicit_surface_reconstruction_3figsPoissonSolverP,Poisson_solver_parameter.png}
Poisson reconstruction with increasing data fitting parameter \f$\lambda\f$. Left: \f$\lambda=1\f$. Middle: \f$\lambda=1000\f$. Right: \f$ \lambda=100000\f$. The blue dots shows the original point clouds.
\cgalFigureEnd

\subsubsection Implicit_surface_reconstruction_3PContouringP Contouring Parameters

Our implementation of the Poisson surface reconstruction algorithm
computes an implicit function represented as a piecewise linear
function over the tetrahedra of a 3D Delaunay triangulation
constructed from the input points then refined through Delaunay
refinement. For this reason, any iso-surface is also piecewise linear
and hence may contain sharp creases. As the contouring algorithm
`make_surface_mesh()` expects a smooth implicit function these
sharp creases may create spurious clusters of vertices in the final
reconstructed surface mesh when setting a small mesh sizing or surface
approximation error parameter (see
\cgalFigureRef{Poisson_surface_reconstruction_3figcontouring_bad}).

One way to avoid these spurious clusters consists of adjusting the
mesh sizing and surface approximation parameters large enough compared
to the average sampling density (obtained through
`compute_average_spacing()`) so that the contouring algorithm
<i>perceives</i> a smooth iso-surface. We recommend to use the following
contouring parameters:

- Max triangle radius: at least 100 times the average spacing.
- Approximation distance: at least 0.25 times the average spacing.

\cgalFigureBegin{Poisson_surface_reconstruction_3figcontouring_bad,contouring_bad.jpg}
Left: surface reconstructed with approximation distance = 0.25 * average spacing. Right: surface reconstructed with approximation distance = 0.15 * average spacing. Notice the spurious cluster on the cheek.
\cgalFigureEnd

\subsubsection Implicit_surface_reconstruction_3PDegradedConditions Degraded Conditions

The conditions listed above are rather restrictive and in practice not
all of them are met in the applications. We now illustrates the
behavior of the algorithm when the conditions are not met in terms of
sampling, wrongly oriented normals, noise and sharp creases.

\subsubsection Implicit_surface_reconstruction_3PSparseSampling Sparse Sampling

The reconstruction algorithm expects a sufficiently dense point
set. Although there is no formal proof of correctness of the algorithm
under certain density conditions due to its variational nature, our
experiments show that the algorithm reconstructs well all thin
features when the local spacing is at most one tenth of the local
feature size (the distance to the medial axis, which captures
altogether curvature, thickness and separation). When this condition
is not met the reconstruction does not reconstruct the thin
undersampled features (see
\cgalFigureRef{Poisson_surface_reconstruction_3figsampling}).

\cgalFigureBegin{Poisson_surface_reconstruction_3figsampling,sampling.jpg}
Left: 50K points sampled on the Neptune trident. The reconstruction (not shown) is successful in this case. Right: point set simplified to 1K points then reconstructed (all input points are depicted with normals). The thin feature is not reconstructed.
\cgalFigureEnd

\subsubsection Implicit_surface_reconstruction_3PLargeHoles Large Holes

The reconstruction is devised to solve for an implicit function which
is an approximate indicator function of an inferred solid. For this
reason the contouring algorithm always extracts a closed surface mesh
and hence is able to fill the small holes where data are missing due,
e.g., to occlusions during acquisition (see
\cgalFigureRef{Poisson_surface_reconstruction_3figholes_bad}).

\cgalFigureBegin{Poisson_surface_reconstruction_3figholes_bad,holes_bad.jpg}
Left: 65K points sampled on a hand with no data captured at the wrist base. Right: reconstructed surface mesh. The surface is properly closed on the fingers and also closed at the wrist but in a less plausible manner.
\cgalFigureEnd

In case of large holes the algorithm still closes them all but the resulting piecewise
linear implicit function may exhibit large triangle patches and sharp creases as the 3D
Delaunay triangulation used for solving is very coarse where the holes are filled.
This can be avoided by a two pass approach. The first pass for a subset of the points
serves to get an approximation of the surface at the holes. This surface then serves to
compute a smoother 3D Delaunay triangulation for the second pass with the full set of points.

\cgalFigureBegin{Poisson_surface_reconstruction_3-fig-two_passes,two-passes.png}
Left: The wrist. Middle: one pass. Right: two passes.
\cgalFigureEnd

\subsubsection Implicit_surface_reconstruction_3PWronglyOriented Wrongly Oriented Normals

The Poisson surface reconstruction approaches solves for an implicit
function whose gradient best matches a set of input normals. Because
it solves this problem in the least squares sense, it is robust to few
isolated wrongly oriented (flipped) normals. Nevertheless a cluster of
wrongly oriented normals leads to an incorrect implicit function and
hence to spurious geometric or even topological distortion (see
\cgalFigureRef{Poisson_surface_reconstruction_3figflipped_normals}).

\cgalFigureBegin{Poisson_surface_reconstruction_3figflipped_normals,flipped_normals.jpg}
Left: points sampled on a sphere with a cluster of wrongly oriented normals. Right: reconstructed surface mesh with a spurious bump.
\cgalFigureEnd

\subsubsection Implicit_surface_reconstruction_3PNoiseandOutliers Noise and Outliers

A large amount of noise inevitably impacts on the reconstruction (see
\cgalFigureRef{Poisson_surface_reconstruction_3fignoise}, top) and the
current implementation does not provide any mean to trade data fitting
for smoothness. Nevertheless if the signal-to-noise ratio is
sufficiently high and/or the surface approximation and sizing
parameters set for contouring the iso-surface is large with respect to
the noise level the output surface mesh will appear smooth (not
shown). If the user wants to produce a smooth and detailed output
surface mesh, we recommend to apply smoothing through
`jet_smooth_point_set()` (see
\cgalFigureRef{Poisson_surface_reconstruction_3fignoise}, bottom).

\cgalFigureBegin{Poisson_surface_reconstruction_3fignoise,noise.jpg}
Top-left: points sampled on a sphere and corrupted with a lot of noise. Top-right: reconstructed surface mesh. Bottom-left: smoothed point set. Bottom-right: reconstructed surface mesh.
\cgalFigureEnd

For a large number of outliers the failure cases (not shown) translate
into spurious small connected components and massive distortion near
the inferred surface. In this case the outliers must be removed
through `remove_outliers()`.

\subsubsection Implicit_surface_reconstruction_3PSharpCreases Sharp Creases

The current reconstruction algorithm is not able to recover the sharp
creases and corners present in the inferred surface. This translates
into smoothed sharp creases.

\cgalFigureBegin{Poisson_surface_reconstruction_3figsharp_features,sharp_features.jpg}
Left: 5K points sampled on a mechanical piece with sharp features (creases, darts and corners). Right: reconstructed surface mesh with smoothed creases.
\cgalFigureEnd

\subsection Implicit_surface_reconstruction_3CSpectral Spectral

Most case studies for Poisson reconstruction also apply to the Spectral method. Here we continue the study for the Spectral method to show its special traits.

\subsubsection Implicit_surface_reconstruction_3Cunoriented unoriented normal
The major difference between Spectral and the other two methods is that Spectral takes unoriented normal as input. This becomes a primary advantage if the normals are wrongly labeled. Poisson and SSD would created holes or broken surface when normals are incorrect while Spectral gives accurate result (see figure \cgalFigureRef{Implicit_surface_reconstruction_3figunoriented}). 


\cgalFigureBegin{Implicit_surface_reconstruction_3figunoriented,unoriented_normal_comparison.png}
Comparison between three reconstruction result for locally inverted normals on a sphere point clouds. Left: Poisson. Middle: SSD. Right:Spectral.
\cgalFigureEnd

\subsubsection Implicit_surface_reconstruction_3SpectralSolverP Spectral Solver's Parameters

There are three parameters that requires tuning when computing the implicit function using Spectral solver: the data fitting term, the laplacian and the bilaplacian term as described in \cgalCite{cgal:a-vvrup-07}. This data fitting term has has exact same effect as described \ref Implicit_surface_reconstruction_3PSolverP "Poisson Solver's Parameters". The bilaplacian term is an additional controllor that increase smoothness as it increases. A empirical trick for tuning is to fix laplacian weight and adjust data fitting and bilaplacian term accordingly (see \cgalFigureRef{Implicit_surface_reconstruction_3figSpectralSolverP}). However, the parameter in Spectral method is more fragile up to scaling comparing to that in Poisson and may need careful tuning.

\cgalFigureBegin{Implicit_surface_reconstruction_3figSpectralSolverP,spectral_solver_parameter.png}
Spectral reconstruction with different data fitting \f$\lambda \f$ and bilaplacian weighting \f$b\f$. Left column: \f$b=0.1\f$. Right column: \f$b=1\f$. Top row: \f$\lambda=10\f$. Bottom row: \f$ \lambda=1 \f$. The blue dots shows the original point clouds.
\cgalFigureEnd

\subsection Implicit_surface_reconstruction_3CSSD SSD

Most case studies for Poisson reconstruction also apply to the SSD method. Here we continue the study for the SSD method to show its special traits.

\subsubsection Implicit_surface_reconstruction_3SSDSolverP SSD Solver's Parameters

There are three parameters that requires tuning when computing the implicit function using SSD solver: the data fitting term, the laplacian term and the hessian term as described in \cgalCite{CalakliT11SSD}. This data fitting term has has exact same effect as described \ref Implicit_surface_reconstruction_3PSolverP "Poisson Solver's Parameters". The hessian term enforces the gradient to be constant far from the surface, which in practice also controls the smoothness. A empirical trick for tuning is to fix laplacian weight and adjust data fitting and hessian term accordingly (see \cgalFigureRef{Implicit_surface_reconstruction_3figSSDSolverP}). However, an over-decreased hessian weight may cause the solver to fail on numerical issses.

\cgalFigureBegin{Implicit_surface_reconstruction_3figSSDSolverP,ssd_solver_parameter.png}
SSD reconstruction with different data fitting \f$\lambda\f$ and hessian weighting \f$h\f$. Left column: \f$h=1e-4\f$. Right column: \f$h=5e-3\f$. Top row: \f$\lambda=10\f$. Bottom row: \f$\lambda=1\f$. The blue dots shows the original point clouds.
\cgalFigureEnd

\section SurfReconstPerformances Performances

We provide some performance numbers for scanning data. We measure the discretization time, implicit function computation time,
the contouring time for a range of approximation distances, the memory occupancy as well as the influence of
the point set simplification. The first two part (\ref Implicit_surface_reconstruction_3PerfDiscretization "Discretization", \ref Implicit_surface_reconstruction_3PerfImplicit "Implicit Function") are tested on a Laptop with Windows 11 64-bits, i7-8750H with 16GB RAM. The software are compiled using MSCV 19 with /O2 (favor speed). The rest of the section are test using a PC running Windows 7 64 bits with an Intel CPU Core 2 Duo
processor clocked at 2.81 GHz and with 8 GB of RAM. The software is compiled with Visual \CC 2010 (VC9) compiler
with the 03 option which maximizes speed.  All measurements were done using the \ref thirdpartyEigen "Eigen" library.

\subsection Implicit_surface_reconstruction_3PerfDiscretization Discretization

The performance of each reconstruction algorithm scales mostly with the variable size of triangulation rather than the size of input. Here we show the discretization result for various point clouds, which correpond to function call `Implicit_reconstruction_function::initialize_point_map()` that includes points generation, Delaunay triangulation and sliver removal. The Deluanay refinement scales almost linearly to the input size. The octree discretization depends on the input size, depth and complexity of the input point clouds, and grows slower than the Deluanay refinement. We do not list the time spend on this function since it comprises very little time comparing to the whole reconstruction procedure. 

<TABLE CELLSPACING=5 >
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=6><HR>
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    Input set 
    <TD class="math" ALIGN=CENTER NOWRAP>
    Input size
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-7 size
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-8 size
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-9 size
    <TD class="math" ALIGN=CENTER NOWRAP>
    Delaunay size
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=6><HR>
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    kitten
    <TD class="math" ALIGN=CENTER NOWRAP>
    5k
    <TD class="math" ALIGN=CENTER NOWRAP>
    64k
    <TD class="math" ALIGN=CENTER NOWRAP>
    64k
    <TD class="math" ALIGN=CENTER NOWRAP>
    64k
    <TD class="math" ALIGN=CENTER NOWRAP>
    34k
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    buddha
    <TD class="math" ALIGN=CENTER NOWRAP>
    72k
    <TD class="math" ALIGN=CENTER NOWRAP>
    210k
    <TD class="math" ALIGN=CENTER NOWRAP>
    740k
    <TD class="math" ALIGN=CENTER NOWRAP>
    877k
    <TD class="math" ALIGN=CENTER NOWRAP>
    496k
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    Bimda_50k
    <TD class="math" ALIGN=CENTER NOWRAP>
    50k
    <TD class="math" ALIGN=CENTER NOWRAP>
    193k
    <TD class="math" ALIGN=CENTER NOWRAP>
    571k
    <TD class="math" ALIGN=CENTER NOWRAP>
    1029k
    <TD class="math" ALIGN=CENTER NOWRAP>
    646k
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    Bimda_500k
    <TD class="math" ALIGN=CENTER NOWRAP>
    500k
    <TD class="math" ALIGN=CENTER NOWRAP>
    216k
    <TD class="math" ALIGN=CENTER NOWRAP>
    834k
    <TD class="math" ALIGN=CENTER NOWRAP>
    2971k
    <TD class="math" ALIGN=CENTER NOWRAP>
    6394k
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=6><HR>
</TABLE>

We also show the time and reconstruction error measured using `CGAL::approximate_Hausdorff_distance()` for a 50k point set sampled from a Bimba con Nastrino surface mesh using Poisson reconction and the recommended contouring parameter `approximation distance = 0.25 * the input point`. The reconstruction accuracy does not have noticable difference in between different discretization options. We recommand choosing a suitable discretization method that balance time and accuracy based on the input.

<TABLE CELLSPACING=5 >
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=4><HR>
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    Discretization method
    <TD class="math" ALIGN=CENTER NOWRAP>
    Solver's size
    <TD class="math" ALIGN=CENTER NOWRAP>
    Total time(s)
    <TD class="math" ALIGN=CENTER NOWRAP>
    Hausdorff distance
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=4><HR>
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-7
    <TD class="math" ALIGN=CENTER NOWRAP>
    190k
    <TD class="math" ALIGN=CENTER NOWRAP>
    17
    <TD class="math" ALIGN=CENTER NOWRAP>
    0.0078
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-8
    <TD class="math" ALIGN=CENTER NOWRAP>
    570k
    <TD class="math" ALIGN=CENTER NOWRAP>
    21
    <TD class="math" ALIGN=CENTER NOWRAP>
    0.0072
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-9
    <TD class="math" ALIGN=CENTER NOWRAP>
    1029k
    <TD class="math" ALIGN=CENTER NOWRAP>
    41
    <TD class="math" ALIGN=CENTER NOWRAP>
    0.0072
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    Delaunay
    <TD class="math" ALIGN=CENTER NOWRAP>
    646k
    <TD class="math" ALIGN=CENTER NOWRAP>
    39
    <TD class="math" ALIGN=CENTER NOWRAP>
    0.0076
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=4><HR>
</TABLE>

\subsection Implicit_surface_reconstruction_3PerfImplicit Implicit Function

The performance analysis for implicit function are split to two parts: the scalability of individual method and reconstruction performance between different methods. The following performance are measured based on resampled data points from a Bimba con Nastrino surface mesh during the function call `Implicit_reconstruction_function::compute_poisson_implicit_function()`, `Implicit_reconstruction_function::compute_spectral_implicit_function()` and `Implicit_reconstruction_function::compute_ssd_implicit_function()`. The contouring settings are set the same as the mentioned in previous section.

\subsubsection Implicit_surface_reconstruction_3PerfImplicitPoisson Poisson
We show the performance of Poisson reconstruction for different size as below. Poisson reconstruction scales well and we show all the reconstruction result with octree depth 8 and Deluanay refinement. The Poisson implicit function computation has a memory peak when solving the Poisson linear system using the sparse linear solver.

<TABLE CELLSPACING=5 >
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=6><HR>
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    Input size
    <TD class="math" ALIGN=CENTER NOWRAP>
    Discretization method
    <TD class="math" ALIGN=CENTER NOWRAP>
    Solver's size
    <TD class="math" ALIGN=CENTER NOWRAP>
    Total time(s)
    <TD class="math" ALIGN=CENTER NOWRAP>
    Memory Peak(MBytes)
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=5><HR>
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    10k
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-8
    <TD class="math" ALIGN=CENTER NOWRAP>
    217k
    <TD class="math" ALIGN=CENTER NOWRAP>
    4.7
    <TD class="math" ALIGN=CENTER NOWRAP>
    380
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    10k
    <TD class="math" ALIGN=CENTER NOWRAP>
    Deluanay
    <TD class="math" ALIGN=CENTER NOWRAP>
    128k
    <TD class="math" ALIGN=CENTER NOWRAP>
    3.5
    <TD class="math" ALIGN=CENTER NOWRAP>
    220
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    50k
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-8
    <TD class="math" ALIGN=CENTER NOWRAP>
    570k
    <TD class="math" ALIGN=CENTER NOWRAP>
    22
    <TD class="math" ALIGN=CENTER NOWRAP>
    980
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    50k
    <TD class="math" ALIGN=CENTER NOWRAP>
    Deluanay
    <TD class="math" ALIGN=CENTER NOWRAP>
    646k
    <TD class="math" ALIGN=CENTER NOWRAP>
    23
    <TD class="math" ALIGN=CENTER NOWRAP>
    1190
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    100k
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-8
    <TD class="math" ALIGN=CENTER NOWRAP>
    710k
    <TD class="math" ALIGN=CENTER NOWRAP>
    31
    <TD class="math" ALIGN=CENTER NOWRAP>
    1250
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    100k
    <TD class="math" ALIGN=CENTER NOWRAP>
    Deluanay
    <TD class="math" ALIGN=CENTER NOWRAP>
    1279k
    <TD class="math" ALIGN=CENTER NOWRAP>
    117
    <TD class="math" ALIGN=CENTER NOWRAP>
    2200
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    500k
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-8
    <TD class="math" ALIGN=CENTER NOWRAP>
    830k
    <TD class="math" ALIGN=CENTER NOWRAP>
    62
    <TD class="math" ALIGN=CENTER NOWRAP>
    1600
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    500k
    <TD class="math" ALIGN=CENTER NOWRAP>
    Deluanay
    <TD class="math" ALIGN=CENTER NOWRAP>
    6394k
    <TD class="math" ALIGN=CENTER NOWRAP>
    1541
    <TD class="math" ALIGN=CENTER NOWRAP>
    11000
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=5><HR>
</TABLE>


\subsubsection Implicit_surface_reconstruction_3PerfImplicitSpectral Spectral
We show the performance of SSD reconstruction for different size as below. For SSD we only show the octree based discretization here for large input since it becomes much slower for variable size reaches several hundred thousand. The time measured also includes the time of a discretization optimization immediately at the beginning of function call `Implicit_reconstruction_function::compute_spectral_implicit_function()`.

<TABLE CELLSPACING=5 >
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=6><HR>
<TR>
<TD class="math" ALIGN=CENTER NOWRAP>
    Input size
    <TD class="math" ALIGN=CENTER NOWRAP>
    Discretization method
    <TD class="math" ALIGN=CENTER NOWRAP>
    Solver's size
    <TD class="math" ALIGN=CENTER NOWRAP>
    Total time(s)
    <TD class="math" ALIGN=CENTER NOWRAP>
    Memory Peak(MBytes)
    <TR><TD ALIGN=LEFT NOWRAP COLSPAN=5><HR>
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    5k
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-7
    <TD class="math" ALIGN=CENTER NOWRAP>
    86k
    <TD class="math" ALIGN=CENTER NOWRAP>
    554
    <TD class="math" ALIGN=CENTER NOWRAP>
    2100
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    10k
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-7
    <TD class="math" ALIGN=CENTER NOWRAP>
    127k
    <TD class="math" ALIGN=CENTER NOWRAP>
    1159
    <TD class="math" ALIGN=CENTER NOWRAP>
    3380
<TR>
<TD class="math" ALIGN=CENTER NOWRAP>
    50k
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-7
    <TD class="math" ALIGN=CENTER NOWRAP>
    190k
    <TD class="math" ALIGN=CENTER NOWRAP>
    2149
    <TD class="math" ALIGN=CENTER NOWRAP>
    10010
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=5><HR>
</TABLE>



\subsubsection Implicit_surface_reconstruction_3PerfImplicitSSD SSD
We show the performance of SSD reconstruction for different size as below. For SSD we only show the octree based discretization here for large input since it becomes much slower for variable size reaches a million.

<TABLE CELLSPACING=5 >
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=6><HR>
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    Input size
    <TD class="math" ALIGN=CENTER NOWRAP>
    Discretization method
    <TD class="math" ALIGN=CENTER NOWRAP>
    Solver's size(s)
    <TD class="math" ALIGN=CENTER NOWRAP>
    Total time(s)
    <TD class="math" ALIGN=CENTER NOWRAP>
    Memory Peak(MBytes)
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=5><HR>
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    5k
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-7
    <TD class="math" ALIGN=CENTER NOWRAP>
    86k
    <TD class="math" ALIGN=CENTER NOWRAP>
    14
    <TD class="math" ALIGN=CENTER NOWRAP>
    1070
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    10k
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-7
    <TD class="math" ALIGN=CENTER NOWRAP>
    127k
    <TD class="math" ALIGN=CENTER NOWRAP>
    22
    <TD class="math" ALIGN=CENTER NOWRAP>
    1590
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    10k
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-8
    <TD class="math" ALIGN=CENTER NOWRAP>
    217k
    <TD class="math" ALIGN=CENTER NOWRAP>
    55
    <TD class="math" ALIGN=CENTER NOWRAP>
    2710
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    50k
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-7
    <TD class="math" ALIGN=CENTER NOWRAP>
    190k
    <TD class="math" ALIGN=CENTER NOWRAP>
    33
    <TD class="math" ALIGN=CENTER NOWRAP>
    2420
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    50k
    <TD class="math" ALIGN=CENTER NOWRAP>
    Octree-8
    <TD class="math" ALIGN=CENTER NOWRAP>
    570k
    <TD class="math" ALIGN=CENTER NOWRAP>
    127
    <TD class="math" ALIGN=CENTER NOWRAP>
    7120
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=5><HR>
</TABLE>

\subsubsection Implicit_surface_reconstruction_3PerfImplicitComp Comparison
We also show the reconstruction error measured using `CGAL::approximate_Hausdorff_distance()` for a 50k point set sampled from a Bimba con Nastrino surface mesh using different reconstruction methods.

<TABLE CELLSPACING=5 >
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=2><HR>
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    Reconstruction Method
    <TD class="math" ALIGN=CENTER NOWRAP>
    Hausdorff distance
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=2><HR>
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    Poisson
    <TD class="math" ALIGN=CENTER NOWRAP>
    0.0048
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    Spectral
    <TD class="math" ALIGN=CENTER NOWRAP>
    0.0054
<TR>
    <TD class="math" ALIGN=CENTER NOWRAP>
    SSD
    <TD class="math" ALIGN=CENTER NOWRAP>
    0.0066
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=2><HR>
</TABLE>

\subsection SurfReconstPerfCont Contouring

The point set chosen for benchmarking the contouring stage is the Bimba con Nastrino point
set simplified to 100k points. We measure the contouring (i.e.\ the call to `make_surface_mesh()`)
duration and the reconstruction error for a range of approximation distances.
The reconstruction error is expressed as the average distance from input points to the reconstructed surface
in mm (the Bimba con Nastrino statue is 324 mm tall).

<TABLE CELLSPACING=5 >
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=3><HR>
<TR>
<TD class="math" ALIGN=CENTER NOWRAP>
Approx. distance (*average spacing)
<TD class="math" ALIGN=CENTER NOWRAP>
Contouring duration (in s)
<TD class="math" ALIGN=CENTER NOWRAP>
Reconstruction error (mm)
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=3><HR>
<TR>

<TD class="math" ALIGN=CENTER NOWRAP>
0.1
<TD class="math" ALIGN=CENTER NOWRAP>
19.2
<TD class="math" ALIGN=CENTER NOWRAP>
0.055
<TR>
<TD class="math" ALIGN=CENTER NOWRAP>
0.25
<TD class="math" ALIGN=CENTER NOWRAP>
6.9
<TD class="math" ALIGN=CENTER NOWRAP>
0.106
<TR>
<TD class="math" ALIGN=CENTER NOWRAP>
0.5
<TD class="math" ALIGN=CENTER NOWRAP>
3.2
<TD class="math" ALIGN=CENTER NOWRAP>
0.18
<TR>
<TD class="math" ALIGN=CENTER NOWRAP>
1
<TD class="math" ALIGN=CENTER NOWRAP>
1.65
<TD class="math" ALIGN=CENTER NOWRAP>
0.36
<TR>
<TD class="math" ALIGN=CENTER NOWRAP>
2
<TD class="math" ALIGN=CENTER NOWRAP>
0.8
<TD class="math" ALIGN=CENTER NOWRAP>
0.76
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=3><HR>
</TABLE>


\cgalFigureBegin{Poisson_surface_reconstruction_3-fig-contouring_bench,contouring_bench.jpg}
Contouring duration (in s) and reconstruction error (mm)
against several approximation distance parameters
for the Bimba con Nastrino point set simplified to 100k points.
\cgalFigureEnd


\subsection SurfReconstPerfPSS Point Set Simplification

Due to the memory limitations described above, we recommend to simplify the point sets captured by laser scanners.\n
We measure the reconstruction error for the Bimba con Nastrino point set (1.6M points) as well as for
simplified versions. All reconstructions use the recommended contouring parameter
`approximation distance = 0.25 * the input point` set's average spacing.
The reconstruction error is expressed as the average distance from input points to the reconstructed surface in mm
(the Bimba con Nastrino statue is 324 mm tall).

<TABLE CELLSPACING=5 >
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=2><HR>
<TR>
<TD class="math" ALIGN=CENTER NOWRAP>
Number of points (x1000)
<TD class="math" ALIGN=CENTER NOWRAP>
Reconstruction error (mm)
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=2><HR>
<TR>
<TD class="math" ALIGN=CENTER NOWRAP>
60
<TD class="math" ALIGN=CENTER NOWRAP>
0.27
<TR>
<TD class="math" ALIGN=CENTER NOWRAP>
120
<TD class="math" ALIGN=CENTER NOWRAP>
0.15
<TR>
<TD class="math" ALIGN=CENTER NOWRAP>
250
<TD class="math" ALIGN=CENTER NOWRAP>
0.11
<TR>
<TD class="math" ALIGN=CENTER NOWRAP>
500
<TD class="math" ALIGN=CENTER NOWRAP>
0.079
<TR>
<TD class="math" ALIGN=CENTER NOWRAP>
1,000
<TD class="math" ALIGN=CENTER NOWRAP>
0.066
<TR>
<TD class="math" ALIGN=CENTER NOWRAP>
1,500
<TD class="math" ALIGN=CENTER NOWRAP>
0.061
<TR>
<TD class="math" ALIGN=CENTER NOWRAP>
1,600
<TD class="math" ALIGN=CENTER NOWRAP>
0.06
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=2><HR>
</TABLE>


\cgalFigureBegin{Poisson_surface_reconstruction_3-fig-simplification_bench,simplification_bench.jpg}
Reconstruction error (mm) against number of points
for the Bimba con Nastrino point set with 1.6M points
as well as for simplified versions.
\cgalFigureEnd

\section SurfReconstDesignHistory Design and Implementation History

The initial implementation for Poisson was essentially done by Laurent Saboret, guided by Pierre Alliez and Ga&euml;l Guennebaud.
For later releases of the package Andreas Fabri worked on performance improvements, and Laurent Rineau added the
two passes for dealing with holes.

The initial implementation for Spectral was done by Tong Zhao, guided by Pierre Alliez, Simon Giraudot and Mathieu Desbrun.


*/
} /* namespace CGAL */
